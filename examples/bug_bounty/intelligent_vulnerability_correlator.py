#!/usr/bin/env python3
"""
üîó INTELLIGENT VULNERABILITY CORRELATION & REPORTING SYSTEM
üß† Advanced pattern recognition and strategic vulnerability analysis
‚ö° Cross-target correlation, risk assessment, and actionable intelligence
üéØ Enterprise-grade vulnerability management for bug bounty operations
"""

import json
import sqlite3
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from collections import defaultdict, Counter
import statistics
import re
from pathlib import Path

@dataclass
class VulnerabilityPattern:
    """Vulnerability pattern structure"""
    pattern_id: str
    pattern_type: str
    affected_targets: List[str]
    common_characteristics: Dict[str, Any]
    severity_distribution: Dict[str, int]
    exploitation_complexity: str
    business_impact: str
    remediation_priority: int
    gemini_analysis: Dict[str, Any]

@dataclass
class SecurityPostureProfile:
    """Security posture assessment"""
    target: str
    overall_score: float
    vulnerability_density: float
    security_maturity: str
    attack_surface_rating: str
    critical_weaknesses: List[str]
    strengths: List[str]
    recommended_actions: List[str]
    comparative_analysis: Dict[str, Any]

class IntelligentVulnerabilityCorrelator:
    """AI-powered vulnerability correlation and analysis"""
    
    def __init__(self, db_path: str = "advanced_multi_target_campaigns.db"):
        self.db_path = db_path
        self.correlation_patterns = {}
        self.vulnerability_taxonomy = self._load_vulnerability_taxonomy()
        self.risk_scoring_model = self._initialize_risk_model()
        
        # Pattern recognition weights
        self.pattern_weights = {
            'technology_correlation': 0.3,
            'vulnerability_type': 0.25,
            'attack_vector': 0.2,
            'business_impact': 0.15,
            'exploitation_ease': 0.1
        }
        
        logging.info("üîó Intelligent Vulnerability Correlator initialized")
    
    def _load_vulnerability_taxonomy(self) -> Dict[str, Any]:
        """Load vulnerability classification taxonomy"""
        return {
            'injection': {
                'types': ['sql_injection', 'xss', 'ldap_injection', 'command_injection'],
                'severity_base': 8.5,
                'exploitation_complexity': 'low',
                'business_impact': 'high'
            },
            'broken_authentication': {
                'types': ['weak_passwords', 'session_fixation', 'credential_stuffing'],
                'severity_base': 7.5,
                'exploitation_complexity': 'medium',
                'business_impact': 'high'
            },
            'security_misconfiguration': {
                'types': ['default_credentials', 'exposed_services', 'verbose_errors'],
                'severity_base': 6.0,
                'exploitation_complexity': 'low',
                'business_impact': 'medium'
            },
            'cryptographic_failures': {
                'types': ['weak_encryption', 'key_management', 'insecure_protocols'],
                'severity_base': 7.0,
                'exploitation_complexity': 'high',
                'business_impact': 'high'
            }
        }
    
    def _initialize_risk_model(self) -> Dict[str, Any]:
        """Initialize risk scoring model"""
        return {
            'cvss_weights': {
                'attack_vector': 0.2,
                'attack_complexity': 0.15,
                'privileges_required': 0.15,
                'user_interaction': 0.1,
                'confidentiality_impact': 0.15,
                'integrity_impact': 0.15,
                'availability_impact': 0.1
            },
            'business_context_multipliers': {
                'public_facing': 1.5,
                'customer_data': 2.0,
                'financial_systems': 2.5,
                'admin_interfaces': 1.8,
                'api_endpoints': 1.3
            }
        }
    
    async def analyze_campaign_vulnerabilities(self, campaign_id: str) -> Dict[str, Any]:
        """Comprehensive vulnerability analysis for a campaign"""
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                
                # Get campaign and results
                campaign_data = self._get_campaign_data(conn, campaign_id)
                if not campaign_data:
                    return {'error': f'Campaign {campaign_id} not found'}
                
                # Extract vulnerabilities from results
                vulnerabilities = self._extract_vulnerabilities(campaign_data)
                
                # Perform correlation analysis
                correlations = self._identify_correlations(vulnerabilities)
                
                # Assess security postures
                posture_profiles = self._assess_security_postures(vulnerabilities, campaign_data['targets'])
                
                # Generate strategic insights
                strategic_insights = self._generate_strategic_insights(vulnerabilities, correlations)
                
                # Create actionable recommendations
                recommendations = self._create_recommendations(correlations, posture_profiles)
                
                # Calculate overall campaign security metrics
                security_metrics = self._calculate_security_metrics(vulnerabilities, posture_profiles)
                
                analysis_report = {
                    'campaign_id': campaign_id,
                    'analysis_timestamp': datetime.now().isoformat(),
                    'executive_summary': {
                        'total_vulnerabilities': len(vulnerabilities),
                        'unique_patterns': len(correlations),
                        'high_risk_targets': len([p for p in posture_profiles.values() if p.overall_score < 6.0]),
                        'critical_findings': len([v for v in vulnerabilities if v.get('severity', 0) >= 8.0]),
                        'overall_security_score': security_metrics['overall_score']
                    },
                    'vulnerability_breakdown': self._categorize_vulnerabilities(vulnerabilities),
                    'correlation_patterns': correlations,
                    'security_postures': {k: self._posture_to_dict(v) for k, v in posture_profiles.items()},
                    'strategic_insights': strategic_insights,
                    'recommendations': recommendations,
                    'security_metrics': security_metrics,
                    'risk_assessment': self._perform_risk_assessment(vulnerabilities, correlations)
                }
                
                # Store analysis results
                self._store_analysis_results(conn, campaign_id, analysis_report)
                
                return analysis_report
                
        except Exception as e:
            logging.error(f"Vulnerability analysis failed for campaign {campaign_id}: {e}")
            return {'error': str(e)}
    
    def _get_campaign_data(self, conn, campaign_id: str) -> Optional[Dict[str, Any]]:
        """Get campaign data from database"""
        cursor = conn.execute("""
            SELECT * FROM multi_campaigns WHERE id = ?
        """, (campaign_id,))
        
        row = cursor.fetchone()
        if not row:
            return None
        
        campaign = dict(row)
        campaign['targets'] = json.loads(campaign['targets'])
        campaign['findings'] = json.loads(campaign['findings']) if campaign['findings'] else []
        
        return campaign
    
    def _extract_vulnerabilities(self, campaign_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract and normalize vulnerabilities from campaign results"""
        vulnerabilities = []
        
        findings = campaign_data.get('findings', [])
        if not findings:
            return vulnerabilities
        
        # Process target results (first element in findings)
        target_results = findings[0] if len(findings) > 0 and isinstance(findings[0], dict) else {}
        
        for target, results in target_results.items():
            if isinstance(results, dict) and results.get('success', False):
                target_vulns = results.get('vulnerabilities', [])
                
                for vuln in target_vulns:
                    if isinstance(vuln, str):
                        # Convert string vulnerability to structured format
                        vuln_data = {
                            'id': f"{target}_{vuln}_{len(vulnerabilities)}",
                            'target': target,
                            'type': vuln,
                            'severity': self._estimate_severity(vuln),
                            'attack_vector': self._determine_attack_vector(vuln),
                            'complexity': self._determine_complexity(vuln),
                            'description': f"{vuln} vulnerability found on {target}",
                            'technologies': results.get('technologies', []),
                            'discovery_context': {
                                'phase': results.get('phase_completed', 'unknown'),
                                'execution_time': results.get('execution_time', 0)
                            }
                        }
                        vulnerabilities.append(vuln_data)
        
        return vulnerabilities
    
    def _estimate_severity(self, vuln_type: str) -> float:
        """Estimate vulnerability severity based on type"""
        severity_map = {
            'sql_injection': 9.0,
            'rce': 9.5,
            'ssrf': 7.5,
            'xss': 6.5,
            'csrf': 5.5,
            'information_disclosure': 4.0,
            'security_misconfiguration': 6.0
        }
        
        for vuln_pattern, severity in severity_map.items():
            if vuln_pattern in vuln_type.lower():
                return severity
        
        return 5.0  # Default medium severity
    
    def _determine_attack_vector(self, vuln_type: str) -> str:
        """Determine attack vector for vulnerability"""
        if any(x in vuln_type.lower() for x in ['network', 'remote', 'injection']):
            return 'network'
        elif any(x in vuln_type.lower() for x in ['local', 'privilege']):
            return 'local'
        elif any(x in vuln_type.lower() for x in ['physical', 'usb']):
            return 'physical'
        else:
            return 'adjacent'
    
    def _determine_complexity(self, vuln_type: str) -> str:
        """Determine exploitation complexity"""
        if any(x in vuln_type.lower() for x in ['injection', 'overflow', 'deserialization']):
            return 'low'
        elif any(x in vuln_type.lower() for x in ['race_condition', 'timing', 'cryptographic']):
            return 'high'
        else:
            return 'medium'
    
    def _identify_correlations(self, vulnerabilities: List[Dict[str, Any]]) -> List[VulnerabilityPattern]:
        """Identify correlation patterns across vulnerabilities"""
        patterns = []
        
        # Group by vulnerability type
        type_groups = defaultdict(list)
        for vuln in vulnerabilities:
            type_groups[vuln['type']].append(vuln)
        
        # Technology-based patterns
        tech_groups = defaultdict(list)
        for vuln in vulnerabilities:
            for tech in vuln.get('technologies', []):
                tech_groups[tech].append(vuln)
        
        # Create patterns for common vulnerability types
        pattern_id = 0
        for vuln_type, vulns in type_groups.items():
            if len(vulns) > 1:  # Pattern requires multiple instances
                pattern = VulnerabilityPattern(
                    pattern_id=f"pattern_{pattern_id}",
                    pattern_type="vulnerability_type",
                    affected_targets=list(set(v['target'] for v in vulns)),
                    common_characteristics={
                        'vulnerability_type': vuln_type,
                        'count': len(vulns),
                        'avg_severity': statistics.mean(v['severity'] for v in vulns),
                        'attack_vectors': list(set(v['attack_vector'] for v in vulns))
                    },
                    severity_distribution=Counter(str(int(v['severity'])) for v in vulns),
                    exploitation_complexity=max(set(v['complexity'] for v in vulns), key=list(v['complexity'] for v in vulns).count),
                    business_impact=self._assess_business_impact(vulns),
                    remediation_priority=self._calculate_remediation_priority(vulns),
                    gemini_analysis={}
                )
                patterns.append(pattern)
                pattern_id += 1
        
        # Technology-based patterns
        for tech, vulns in tech_groups.items():
            if len(vulns) > 1:
                pattern = VulnerabilityPattern(
                    pattern_id=f"pattern_{pattern_id}",
                    pattern_type="technology_correlation",
                    affected_targets=list(set(v['target'] for v in vulns)),
                    common_characteristics={
                        'technology': tech,
                        'vulnerability_types': list(set(v['type'] for v in vulns)),
                        'count': len(vulns),
                        'avg_severity': statistics.mean(v['severity'] for v in vulns)
                    },
                    severity_distribution=Counter(str(int(v['severity'])) for v in vulns),
                    exploitation_complexity='medium',
                    business_impact=self._assess_business_impact(vulns),
                    remediation_priority=self._calculate_remediation_priority(vulns),
                    gemini_analysis={}
                )
                patterns.append(pattern)
                pattern_id += 1
        
        return patterns
    
    def _assess_business_impact(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Assess business impact of vulnerability pattern"""
        max_severity = max(v['severity'] for v in vulnerabilities)
        
        if max_severity >= 9.0:
            return 'critical'
        elif max_severity >= 7.0:
            return 'high'
        elif max_severity >= 5.0:
            return 'medium'
        else:
            return 'low'
    
    def _calculate_remediation_priority(self, vulnerabilities: List[Dict[str, Any]]) -> int:
        """Calculate remediation priority (1-10, 10 being highest)"""
        severity_score = statistics.mean(v['severity'] for v in vulnerabilities)
        count_factor = min(len(vulnerabilities) / 5.0, 2.0)  # Cap at 2x multiplier
        
        priority = (severity_score * count_factor) / 10.0 * 10
        return max(1, min(10, int(priority)))
    
    def _assess_security_postures(self, vulnerabilities: List[Dict[str, Any]], targets: List[str]) -> Dict[str, SecurityPostureProfile]:
        """Assess security posture for each target"""
        profiles = {}
        
        for target in targets:
            target_vulns = [v for v in vulnerabilities if v['target'] == target]
            
            if not target_vulns:
                # No vulnerabilities found - could be good or incomplete testing
                profiles[target] = SecurityPostureProfile(
                    target=target,
                    overall_score=7.0,  # Neutral score for no findings
                    vulnerability_density=0.0,
                    security_maturity='unknown',
                    attack_surface_rating='low',
                    critical_weaknesses=[],
                    strengths=['No obvious vulnerabilities detected'],
                    recommended_actions=['Conduct deeper security assessment'],
                    comparative_analysis={}
                )
                continue
            
            # Calculate metrics
            avg_severity = statistics.mean(v['severity'] for v in target_vulns)
            vuln_density = len(target_vulns)
            critical_count = len([v for v in target_vulns if v['severity'] >= 8.0])
            
            # Overall score (10 - normalized severity, adjusted for count)
            overall_score = max(0, 10 - (avg_severity + vuln_density * 0.2))
            
            # Determine security maturity
            if avg_severity < 5.0 and critical_count == 0:
                maturity = 'mature'
            elif avg_severity < 7.0 and critical_count <= 1:
                maturity = 'developing'
            else:
                maturity = 'immature'
            
            # Critical weaknesses
            critical_weaknesses = [v['type'] for v in target_vulns if v['severity'] >= 8.0]
            
            # Strengths (inverse of weaknesses)
            all_vuln_types = set(v['type'] for v in vulnerabilities)
            target_vuln_types = set(v['type'] for v in target_vulns)
            strengths = list(all_vuln_types - target_vuln_types)
            
            profiles[target] = SecurityPostureProfile(
                target=target,
                overall_score=overall_score,
                vulnerability_density=vuln_density,
                security_maturity=maturity,
                attack_surface_rating=self._rate_attack_surface(target_vulns),
                critical_weaknesses=critical_weaknesses,
                strengths=strengths[:5],  # Top 5 strengths
                recommended_actions=self._generate_target_recommendations(target_vulns),
                comparative_analysis={}
            )
        
        # Add comparative analysis
        if len(profiles) > 1:
            scores = [p.overall_score for p in profiles.values()]
            avg_score = statistics.mean(scores)
            
            for target, profile in profiles.items():
                profile.comparative_analysis = {
                    'rank': sorted(scores, reverse=True).index(profile.overall_score) + 1,
                    'percentile': (profile.overall_score - min(scores)) / (max(scores) - min(scores)) * 100 if max(scores) != min(scores) else 50,
                    'relative_to_average': 'above' if profile.overall_score > avg_score else 'below'
                }
        
        return profiles
    
    def _rate_attack_surface(self, target_vulns: List[Dict[str, Any]]) -> str:
        """Rate attack surface based on vulnerabilities"""
        network_vulns = len([v for v in target_vulns if v['attack_vector'] == 'network'])
        total_vulns = len(target_vulns)
        
        if total_vulns == 0:
            return 'minimal'
        elif network_vulns / total_vulns > 0.7:
            return 'extensive'
        elif network_vulns / total_vulns > 0.4:
            return 'moderate'
        else:
            return 'limited'
    
    def _generate_target_recommendations(self, target_vulns: List[Dict[str, Any]]) -> List[str]:
        """Generate specific recommendations for a target"""
        recommendations = []
        
        vuln_types = Counter(v['type'] for v in target_vulns)
        
        if 'sql_injection' in vuln_types:
            recommendations.append("Implement parameterized queries and input validation")
        if 'xss' in vuln_types:
            recommendations.append("Deploy Content Security Policy and output encoding")
        if 'ssrf' in vuln_types:
            recommendations.append("Implement URL whitelist and network segmentation")
        
        high_severity_count = len([v for v in target_vulns if v['severity'] >= 7.0])
        if high_severity_count > 3:
            recommendations.append("Conduct immediate security code review")
        
        return recommendations[:5]  # Top 5 recommendations
    
    def _categorize_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Categorize vulnerabilities for reporting"""
        categories = {}
        
        # By severity
        categories['by_severity'] = {
            'critical': len([v for v in vulnerabilities if v['severity'] >= 9.0]),
            'high': len([v for v in vulnerabilities if 7.0 <= v['severity'] < 9.0]),
            'medium': len([v for v in vulnerabilities if 4.0 <= v['severity'] < 7.0]),
            'low': len([v for v in vulnerabilities if v['severity'] < 4.0])
        }
        
        # By type
        categories['by_type'] = dict(Counter(v['type'] for v in vulnerabilities))
        
        # By attack vector
        categories['by_attack_vector'] = dict(Counter(v['attack_vector'] for v in vulnerabilities))
        
        # By complexity
        categories['by_complexity'] = dict(Counter(v['complexity'] for v in vulnerabilities))
        
        return categories
    
    def _generate_strategic_insights(self, vulnerabilities: List[Dict[str, Any]], 
                                   correlations: List[VulnerabilityPattern]) -> Dict[str, Any]:
        """Generate strategic security insights"""
        insights = {
            'threat_landscape': self._analyze_threat_landscape(vulnerabilities),
            'attack_paths': self._identify_attack_paths(vulnerabilities),
            'defense_gaps': self._identify_defense_gaps(vulnerabilities, correlations),
            'trend_analysis': self._analyze_trends(vulnerabilities)
        }
        
        return insights
    
    def _analyze_threat_landscape(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze the threat landscape"""
        if not vulnerabilities:
            return {'status': 'minimal_exposure', 'primary_threats': []}
        
        threat_vectors = Counter(v['attack_vector'] for v in vulnerabilities)
        severity_distribution = Counter('critical' if v['severity'] >= 9.0 else 
                                      'high' if v['severity'] >= 7.0 else 
                                      'medium' if v['severity'] >= 4.0 else 'low' 
                                      for v in vulnerabilities)
        
        return {
            'primary_attack_vectors': dict(threat_vectors.most_common(3)),
            'severity_distribution': dict(severity_distribution),
            'risk_level': 'high' if severity_distribution['critical'] > 0 else 'medium',
            'exposure_rating': min(10, len(vulnerabilities) / 2)
        }
    
    def _identify_attack_paths(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Identify potential attack paths"""
        paths = []
        
        # Group by target to identify multi-step attacks
        target_vulns = defaultdict(list)
        for vuln in vulnerabilities:
            target_vulns[vuln['target']].append(vuln)
        
        for target, vulns in target_vulns.items():
            if len(vulns) > 1:
                # Sort by severity to create attack progression
                sorted_vulns = sorted(vulns, key=lambda x: x['severity'], reverse=True)
                
                path = {
                    'target': target,
                    'attack_chain': [v['type'] for v in sorted_vulns[:3]],  # Top 3 vulnerabilities
                    'chain_severity': statistics.mean(v['severity'] for v in sorted_vulns[:3]),
                    'exploitation_sequence': self._create_exploitation_sequence(sorted_vulns[:3])
                }
                paths.append(path)
        
        return paths
    
    def _create_exploitation_sequence(self, vulnerabilities: List[Dict[str, Any]]) -> List[str]:
        """Create logical exploitation sequence"""
        sequence = []
        
        for vuln in vulnerabilities:
            if vuln['type'] == 'sql_injection':
                sequence.append("Database compromise")
            elif vuln['type'] == 'xss':
                sequence.append("Client-side code execution")
            elif vuln['type'] == 'ssrf':
                sequence.append("Internal network access")
            elif vuln['type'] == 'rce':
                sequence.append("Remote command execution")
            else:
                sequence.append(f"Exploit {vuln['type']}")
        
        return sequence
    
    def _identify_defense_gaps(self, vulnerabilities: List[Dict[str, Any]], 
                             correlations: List[VulnerabilityPattern]) -> Dict[str, Any]:
        """Identify defense gaps"""
        gaps = {
            'input_validation': len([v for v in vulnerabilities if 'injection' in v['type']]) > 0,
            'output_encoding': len([v for v in vulnerabilities if 'xss' in v['type']]) > 0,
            'authentication': len([v for v in vulnerabilities if 'auth' in v['type']]) > 0,
            'authorization': len([v for v in vulnerabilities if 'privilege' in v['type']]) > 0,
            'network_security': len([v for v in vulnerabilities if v['attack_vector'] == 'network']) > 2
        }
        
        # Identify systemic issues from patterns
        systemic_issues = []
        for pattern in correlations:
            if len(pattern.affected_targets) > 1:
                systemic_issues.append(f"Systemic {pattern.pattern_type} affecting {len(pattern.affected_targets)} targets")
        
        return {
            'control_gaps': {k: v for k, v in gaps.items() if v},
            'systemic_issues': systemic_issues,
            'priority_areas': self._prioritize_defense_areas(gaps)
        }
    
    def _prioritize_defense_areas(self, gaps: Dict[str, bool]) -> List[str]:
        """Prioritize defense areas for improvement"""
        priority_order = ['input_validation', 'authentication', 'authorization', 'output_encoding', 'network_security']
        return [area for area in priority_order if gaps.get(area, False)]
    
    def _analyze_trends(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze vulnerability trends"""
        # For demo purposes, provide basic trend analysis
        return {
            'most_common_vulnerability': Counter(v['type'] for v in vulnerabilities).most_common(1)[0] if vulnerabilities else ('none', 0),
            'average_severity': statistics.mean(v['severity'] for v in vulnerabilities) if vulnerabilities else 0,
            'complexity_distribution': dict(Counter(v['complexity'] for v in vulnerabilities))
        }
    
    def _create_recommendations(self, correlations: List[VulnerabilityPattern], 
                              postures: Dict[str, SecurityPostureProfile]) -> Dict[str, Any]:
        """Create actionable recommendations"""
        recommendations = {
            'immediate_actions': [],
            'strategic_initiatives': [],
            'resource_allocation': {},
            'timeline': {}
        }
        
        # Immediate actions from high-priority patterns
        for pattern in sorted(correlations, key=lambda x: x.remediation_priority, reverse=True)[:3]:
            if pattern.remediation_priority >= 8:
                recommendations['immediate_actions'].append(
                    f"Address {pattern.pattern_type} affecting {len(pattern.affected_targets)} targets"
                )
        
        # Strategic initiatives from posture analysis
        low_scoring_targets = [target for target, posture in postures.items() if posture.overall_score < 5.0]
        if low_scoring_targets:
            recommendations['strategic_initiatives'].append(
                f"Comprehensive security review for {len(low_scoring_targets)} high-risk targets"
            )
        
        return recommendations
    
    def _calculate_security_metrics(self, vulnerabilities: List[Dict[str, Any]], 
                                  postures: Dict[str, SecurityPostureProfile]) -> Dict[str, Any]:
        """Calculate overall security metrics"""
        if not postures:
            return {'overall_score': 7.0, 'confidence': 'low'}
        
        overall_score = statistics.mean(p.overall_score for p in postures.values())
        
        return {
            'overall_score': round(overall_score, 2),
            'vulnerability_density': len(vulnerabilities) / len(postures) if postures else 0,
            'critical_vulnerability_ratio': len([v for v in vulnerabilities if v['severity'] >= 8.0]) / max(len(vulnerabilities), 1),
            'security_maturity_distribution': dict(Counter(p.security_maturity for p in postures.values())),
            'confidence': 'high' if len(vulnerabilities) > 5 else 'medium'
        }
    
    def _perform_risk_assessment(self, vulnerabilities: List[Dict[str, Any]], 
                               correlations: List[VulnerabilityPattern]) -> Dict[str, Any]:
        """Perform comprehensive risk assessment"""
        if not vulnerabilities:
            return {'overall_risk': 'low', 'risk_score': 2.0}
        
        # Calculate risk factors
        severity_risk = statistics.mean(v['severity'] for v in vulnerabilities) / 10
        volume_risk = min(len(vulnerabilities) / 20, 1.0)  # Cap at 20 vulnerabilities
        correlation_risk = len(correlations) / 10  # Pattern-based risk
        
        overall_risk_score = (severity_risk * 0.5 + volume_risk * 0.3 + correlation_risk * 0.2) * 10
        
        if overall_risk_score >= 8.0:
            risk_level = 'critical'
        elif overall_risk_score >= 6.0:
            risk_level = 'high'
        elif overall_risk_score >= 4.0:
            risk_level = 'medium'
        else:
            risk_level = 'low'
        
        return {
            'overall_risk': risk_level,
            'risk_score': round(overall_risk_score, 2),
            'contributing_factors': {
                'severity_factor': round(severity_risk * 10, 2),
                'volume_factor': round(volume_risk * 10, 2),
                'correlation_factor': round(correlation_risk * 10, 2)
            }
        }
    
    def _posture_to_dict(self, posture: SecurityPostureProfile) -> Dict[str, Any]:
        """Convert security posture to dictionary"""
        return {
            'target': posture.target,
            'overall_score': posture.overall_score,
            'vulnerability_density': posture.vulnerability_density,
            'security_maturity': posture.security_maturity,
            'attack_surface_rating': posture.attack_surface_rating,
            'critical_weaknesses': posture.critical_weaknesses,
            'strengths': posture.strengths,
            'recommended_actions': posture.recommended_actions,
            'comparative_analysis': posture.comparative_analysis
        }
    
    def _store_analysis_results(self, conn, campaign_id: str, analysis_report: Dict[str, Any]):
        """Store analysis results in database"""
        try:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS vulnerability_analyses (
                    id TEXT PRIMARY KEY,
                    campaign_id TEXT NOT NULL,
                    analysis_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    analysis_data TEXT NOT NULL,
                    FOREIGN KEY (campaign_id) REFERENCES multi_campaigns (id)
                )
            """)
            
            analysis_id = f"analysis_{campaign_id}_{int(datetime.now().timestamp())}"
            conn.execute("""
                INSERT INTO vulnerability_analyses (id, campaign_id, analysis_data)
                VALUES (?, ?, ?)
            """, (analysis_id, campaign_id, json.dumps(analysis_report)))
            
            conn.commit()
            logging.info(f"üíæ Stored vulnerability analysis {analysis_id}")
            
        except Exception as e:
            logging.error(f"Failed to store analysis results: {e}")

async def demonstrate_vulnerability_correlation():
    """Demonstrate vulnerability correlation and analysis"""
    print("üîó INTELLIGENT VULNERABILITY CORRELATION DEMONSTRATION")
    print("=" * 65)
    
    # Check for existing campaigns
    correlator = IntelligentVulnerabilityCorrelator()
    
    try:
        with sqlite3.connect(correlator.db_path) as conn:
            cursor = conn.execute("SELECT id FROM multi_campaigns ORDER BY created_at DESC LIMIT 1")
            row = cursor.fetchone()
            
            if row:
                campaign_id = row[0]
                print(f"üìä Analyzing vulnerabilities for campaign: {campaign_id}")
                
                # Perform correlation analysis
                analysis = await correlator.analyze_campaign_vulnerabilities(campaign_id)
                
                if 'error' in analysis:
                    print(f"‚ùå Analysis failed: {analysis['error']}")
                    return
                
                # Display results
                print(f"\nüìà EXECUTIVE SUMMARY:")
                summary = analysis['executive_summary']
                print(f"   Total Vulnerabilities: {summary['total_vulnerabilities']}")
                print(f"   Unique Patterns: {summary['unique_patterns']}")
                print(f"   High-Risk Targets: {summary['high_risk_targets']}")
                print(f"   Critical Findings: {summary['critical_findings']}")
                print(f"   Overall Security Score: {summary['overall_security_score']:.1f}/10")
                
                print(f"\nüéØ VULNERABILITY BREAKDOWN:")
                breakdown = analysis['vulnerability_breakdown']
                for category, data in breakdown.items():
                    print(f"   {category.replace('_', ' ').title()}:")
                    for key, value in data.items():
                        print(f"     {key}: {value}")
                
                print(f"\nüîó CORRELATION PATTERNS:")
                patterns = analysis['correlation_patterns']
                for i, pattern in enumerate(patterns[:3], 1):  # Show top 3
                    print(f"   Pattern {i}: {pattern.pattern_type}")
                    print(f"     Affects: {len(pattern.affected_targets)} targets")
                    print(f"     Priority: {pattern.remediation_priority}/10")
                
                print(f"\nüõ°Ô∏è  SECURITY POSTURES:")
                postures = analysis['security_postures']
                for target, posture in postures.items():
                    print(f"   {target}: {posture['overall_score']:.1f}/10 ({posture['security_maturity']})")
                
                print(f"\n‚ö†Ô∏è  RISK ASSESSMENT:")
                risk = analysis['risk_assessment']
                print(f"   Overall Risk: {risk['overall_risk'].upper()}")
                print(f"   Risk Score: {risk['risk_score']}/10")
                
                print(f"\nüí° TOP RECOMMENDATIONS:")
                recommendations = analysis['recommendations']
                for action in recommendations['immediate_actions'][:3]:
                    print(f"   ‚Ä¢ {action}")
                
                return analysis
                
            else:
                print("‚ö†Ô∏è  No campaigns found. Run the multi-target orchestrator first.")
                return None
                
    except Exception as e:
        print(f"‚ùå Demonstration failed: {e}")
        return None

if __name__ == "__main__":
    import asyncio
    
    print("üîó Intelligent Vulnerability Correlation & Reporting System")
    
    results = asyncio.run(demonstrate_vulnerability_correlation())
    
    if results:
        print(f"\nüí´ Vulnerability correlation analysis completed successfully!")
    else:
        print(f"\n‚ùå Analysis failed or no data available")
