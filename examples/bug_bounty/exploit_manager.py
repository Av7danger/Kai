#!/usr/bin/env python3
"""
ðŸ”¥ Advanced Exploitation & Post-Exploitation Manager
Orchestrates exploitation, privilege escalation, lateral movement, and data exfiltration

Features:
- Modular exploit system with safety controls
- Privilege escalation automation
- Lateral movement capabilities
- Data exfiltration simulation
- Session tracking and audit logging
- Impact assessment and reporting
"""

import os
import json
import time
import hashlib
import sqlite3
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from pathlib import Path
import logging
import yaml

logger = logging.getLogger(__name__)

@dataclass
class ExploitSession:
    """Exploitation session tracking"""
    id: str
    target: str
    session_type: str  # rce, sqli, xss, privesc, lateral, exfil
    status: str  # running, completed, failed, stopped
    start_time: datetime
    end_time: Optional[datetime] = None
    payload: Optional[str] = None
    result: Optional[str] = None
    impact_level: str = 'low'  # low, medium, high, critical
    safety_mode: bool = True  # dry-run mode
    metadata: Dict[str, Any] = None

@dataclass
class ExploitResult:
    """Exploitation result"""
    session_id: str
    success: bool
    output: str
    data_extracted: Optional[str] = None
    files_accessed: List[str] = None
    credentials_found: List[str] = None
    network_access: Dict[str, Any] = None
    timestamp: datetime = None

@dataclass
class PrivilegeEscalationResult:
    """Privilege escalation result"""
    session_id: str
    technique: str
    success: bool
    original_user: str
    elevated_user: str
    method_used: str
    output: str
    timestamp: datetime = None

@dataclass
class DataExfiltrationResult:
    """Data exfiltration result"""
    session_id: str
    target: str
    data_type: str  # files, database, credentials, configs
    files_exfiltrated: List[str]
    data_size: int
    sensitive_data_found: List[str]
    exfiltration_method: str
    success: bool
    output: str
    timestamp: datetime = None

class ExploitManager:
    """Advanced exploitation and post-exploitation manager"""
    
    def __init__(self, config_path: str = 'exploitation_config.yml'):
        self.config_path = config_path
        self.config = self._load_config()
        
        # Database
        self.db_path = 'exploitation.db'
        self._init_database()
        
        # Session management
        self.active_sessions: Dict[str, ExploitSession] = {}
        
        # Safety controls
        self.safety_enabled = self.config.get('safety', {}).get('enabled', True)
        self.require_consent = self.config.get('safety', {}).get('require_consent', True)
        self.dry_run_mode = self.config.get('safety', {}).get('dry_run_mode', True)
        
        # Create output directories
        self.output_dir = Path('exploitation_results')
        self.output_dir.mkdir(exist_ok=True)
        
        for subdir in ['sessions', 'reports', 'payloads', 'logs']:
            (self.output_dir / subdir).mkdir(exist_ok=True)
    
    def _load_config(self) -> Dict:
        """Load exploitation configuration"""
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                return yaml.safe_load(f)
        else:
            return self._get_default_config()
    
    def _get_default_config(self) -> Dict:
        """Get default exploitation configuration"""
        return {
            'safety': {
                'enabled': True,
                'require_consent': True,
                'dry_run_mode': True,
                'max_concurrent_sessions': 3,
                'session_timeout_minutes': 30
            },
            'exploitation': {
                'default_timeout': 60,
                'retry_attempts': 3,
                'payload_validation': True
            },
            'modules': {
                'rce': {'enabled': True, 'timeout': 30},
                'sqli': {'enabled': True, 'timeout': 45},
                'xss': {'enabled': True, 'timeout': 20},
                'privesc': {'enabled': True, 'timeout': 60},
                'lateral': {'enabled': True, 'timeout': 90},
                'exfil': {'enabled': True, 'timeout': 120}
            },
            'reporting': {
                'auto_generate': True,
                'include_payloads': False,
                'export_formats': ['json', 'html']
            }
        }
    
    def _init_database(self):
        """Initialize exploitation database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Exploitation sessions table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploit_sessions (
                id TEXT PRIMARY KEY,
                target TEXT NOT NULL,
                session_type TEXT,
                status TEXT,
                start_time TEXT,
                end_time TEXT,
                payload TEXT,
                result TEXT,
                impact_level TEXT,
                safety_mode BOOLEAN,
                metadata TEXT
            )
        ''')
        
        # Exploit results table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploit_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT,
                success BOOLEAN,
                output TEXT,
                data_extracted TEXT,
                files_accessed TEXT,
                credentials_found TEXT,
                network_access TEXT,
                timestamp TEXT,
                FOREIGN KEY (session_id) REFERENCES exploit_sessions (id)
            )
        ''')
        
        # Privilege escalation results table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS privesc_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT,
                technique TEXT,
                success BOOLEAN,
                original_user TEXT,
                elevated_user TEXT,
                method_used TEXT,
                output TEXT,
                timestamp TEXT,
                FOREIGN KEY (session_id) REFERENCES exploit_sessions (id)
            )
        ''')
        
        # Data exfiltration results table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exfil_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT,
                target TEXT,
                data_type TEXT,
                files_exfiltrated TEXT,
                data_size INTEGER,
                sensitive_data_found TEXT,
                exfiltration_method TEXT,
                success BOOLEAN,
                output TEXT,
                timestamp TEXT,
                FOREIGN KEY (session_id) REFERENCES exploit_sessions (id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def create_exploit_session(self, target: str, session_type: str, 
                              payload: Optional[str] = None, 
                              safety_mode: bool = True) -> str:
        """Create a new exploitation session"""
        session_id = hashlib.md5(f"{target}_{session_type}_{time.time()}".encode()).hexdigest()[:12]
        
        session = ExploitSession(
            id=session_id,
            target=target,
            session_type=session_type,
            status='running',
            start_time=datetime.now(),
            payload=payload,
            safety_mode=safety_mode or self.dry_run_mode,
            metadata={}
        )
        
        self.active_sessions[session_id] = session
        self._save_session_to_db(session)
        
        logger.info(f"Created exploitation session {session_id} for {target}")
        return session_id
    
    def _save_session_to_db(self, session: ExploitSession):
        """Save session to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO exploit_sessions 
            (id, target, session_type, status, start_time, end_time, payload, 
             result, impact_level, safety_mode, metadata)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            session.id, session.target, session.session_type, session.status,
            session.start_time.isoformat(),
            session.end_time.isoformat() if session.end_time else None,
            session.payload, session.result, session.impact_level,
            session.safety_mode, json.dumps(session.metadata or {})
        ))
        
        conn.commit()
        conn.close()
    
    def execute_rce_exploit(self, session_id: str, method: str = 'command_injection') -> ExploitResult:
        """Execute RCE exploit"""
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")
        
        session = self.active_sessions[session_id]
        
        # Safety check
        if self.safety_enabled and not self._check_safety_consent(session):
            raise Exception("Safety consent required for exploitation")
        
        try:
            if session.safety_mode:
                result = ExploitResult(
                    session_id=session_id,
                    success=True,
                    output=f"[SAFETY MODE] RCE {method} simulation successful",
                    data_extracted="Simulated command output",
                    files_accessed=["/etc/passwd", "/tmp/test"],
                    credentials_found=["admin:password123"],
                    timestamp=datetime.now()
                )
            else:
                result = ExploitResult(
                    session_id=session_id,
                    success=False,
                    output=f"RCE {method} not implemented in demo mode",
                    timestamp=datetime.now()
                )
            
            self._save_exploit_result(result)
            self._update_session_status(session_id, 'completed' if result.success else 'failed')
            
            return result
            
        except Exception as e:
            logger.error(f"RCE exploit failed: {e}")
            result = ExploitResult(
                session_id=session_id,
                success=False,
                output=str(e),
                timestamp=datetime.now()
            )
            self._save_exploit_result(result)
            self._update_session_status(session_id, 'failed')
            return result
    
    def execute_sqli_exploit(self, session_id: str, method: str = 'boolean_based') -> ExploitResult:
        """Execute SQL injection exploit"""
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")
        
        session = self.active_sessions[session_id]
        
        try:
            if session.safety_mode:
                result = ExploitResult(
                    session_id=session_id,
                    success=True,
                    output=f"[SAFETY MODE] SQL injection {method} simulation successful",
                    data_extracted="Simulated database data",
                    files_accessed=[],
                    credentials_found=["user1:pass1", "user2:pass2"],
                    timestamp=datetime.now()
                )
            else:
                result = ExploitResult(
                    session_id=session_id,
                    success=False,
                    output=f"SQL injection {method} not implemented in demo mode",
                    timestamp=datetime.now()
                )
            
            self._save_exploit_result(result)
            self._update_session_status(session_id, 'completed' if result.success else 'failed')
            
            return result
            
        except Exception as e:
            logger.error(f"SQL injection exploit failed: {e}")
            result = ExploitResult(
                session_id=session_id,
                success=False,
                output=str(e),
                timestamp=datetime.now()
            )
            self._save_exploit_result(result)
            self._update_session_status(session_id, 'failed')
            return result
    
    def execute_privesc(self, session_id: str, technique: str = 'sudo_exploitation') -> PrivilegeEscalationResult:
        """Execute privilege escalation"""
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")
        
        session = self.active_sessions[session_id]
        
        try:
            if session.safety_mode:
                result = PrivilegeEscalationResult(
                    session_id=session_id,
                    technique=technique,
                    success=True,
                    original_user="user",
                    elevated_user="root",
                    method_used=technique,
                    output=f"[SAFETY MODE] Privilege escalation {technique} simulation successful",
                    timestamp=datetime.now()
                )
            else:
                result = PrivilegeEscalationResult(
                    session_id=session_id,
                    technique=technique,
                    success=False,
                    original_user="user",
                    elevated_user="user",
                    method_used="none",
                    output=f"Privilege escalation {technique} not implemented in demo mode",
                    timestamp=datetime.now()
                )
            
            self._save_privesc_result(result)
            return result
            
        except Exception as e:
            logger.error(f"Privilege escalation failed: {e}")
            result = PrivilegeEscalationResult(
                session_id=session_id,
                technique=technique,
                success=False,
                original_user="user",
                elevated_user="user",
                method_used="none",
                output=str(e),
                timestamp=datetime.now()
            )
            self._save_privesc_result(result)
            return result
    
    def execute_data_exfiltration(self, session_id: str, data_type: str = 'files') -> DataExfiltrationResult:
        """Execute data exfiltration"""
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")
        
        session = self.active_sessions[session_id]
        
        try:
            if session.safety_mode:
                result = DataExfiltrationResult(
                    session_id=session_id,
                    target=session.target,
                    data_type=data_type,
                    files_exfiltrated=["/etc/passwd", "/etc/shadow", "config.php"],
                    data_size=2048,
                    sensitive_data_found=["database_credentials", "api_keys"],
                    exfiltration_method="http_post",
                    success=True,
                    output=f"[SAFETY MODE] Data exfiltration {data_type} simulation successful",
                    timestamp=datetime.now()
                )
            else:
                result = DataExfiltrationResult(
                    session_id=session_id,
                    target=session.target,
                    data_type=data_type,
                    files_exfiltrated=[],
                    data_size=0,
                    sensitive_data_found=[],
                    exfiltration_method="none",
                    success=False,
                    output=f"Data exfiltration {data_type} not implemented in demo mode",
                    timestamp=datetime.now()
                )
            
            self._save_exfil_result(result)
            return result
            
        except Exception as e:
            logger.error(f"Data exfiltration failed: {e}")
            result = DataExfiltrationResult(
                session_id=session_id,
                target=session.target,
                data_type=data_type,
                files_exfiltrated=[],
                data_size=0,
                sensitive_data_found=[],
                exfiltration_method="none",
                success=False,
                output=str(e),
                timestamp=datetime.now()
            )
            self._save_exfil_result(result)
            return result
    
    def _check_safety_consent(self, session: ExploitSession) -> bool:
        """Check if safety consent is given"""
        if not self.require_consent:
            return True
        
        # In a real implementation, this would check for explicit consent
        return os.getenv('EXPLOIT_CONSENT', 'false').lower() == 'true'
    
    def _save_exploit_result(self, result: ExploitResult):
        """Save exploit result to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO exploit_results 
            (session_id, success, output, data_extracted, files_accessed,
             credentials_found, network_access, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            result.session_id, result.success, result.output,
            result.data_extracted,
            json.dumps(result.files_accessed or []),
            json.dumps(result.credentials_found or []),
            json.dumps(result.network_access or {}),
            result.timestamp.isoformat() if result.timestamp else datetime.now().isoformat()
        ))
        
        conn.commit()
        conn.close()
    
    def _save_privesc_result(self, result: PrivilegeEscalationResult):
        """Save privilege escalation result to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO privesc_results 
            (session_id, technique, success, original_user, elevated_user,
             method_used, output, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            result.session_id, result.technique, result.success,
            result.original_user, result.elevated_user, result.method_used,
            result.output, result.timestamp.isoformat() if result.timestamp else datetime.now().isoformat()
        ))
        
        conn.commit()
        conn.close()
    
    def _save_exfil_result(self, result: DataExfiltrationResult):
        """Save data exfiltration result to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO exfil_results 
            (session_id, target, data_type, files_exfiltrated, data_size,
             sensitive_data_found, exfiltration_method, success, output, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            result.session_id, result.target, result.data_type,
            json.dumps(result.files_exfiltrated or []), result.data_size,
            json.dumps(result.sensitive_data_found or []), result.exfiltration_method,
            result.success, result.output, result.timestamp.isoformat() if result.timestamp else datetime.now().isoformat()
        ))
        
        conn.commit()
        conn.close()
    
    def _update_session_status(self, session_id: str, status: str):
        """Update session status in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE exploit_sessions 
            SET status = ?, end_time = ?
            WHERE id = ?
        ''', (status, datetime.now().isoformat(), session_id))
        
        conn.commit()
        conn.close()
        
        # Update active session
        if session_id in self.active_sessions:
            self.active_sessions[session_id].status = status
            self.active_sessions[session_id].end_time = datetime.now()
    
    def get_session_status(self, session_id: str) -> Optional[ExploitSession]:
        """Get session status"""
        return self.active_sessions.get(session_id)
    
    def get_all_sessions(self) -> List[ExploitSession]:
        """Get all active sessions"""
        return list(self.active_sessions.values())
    
    def stop_session(self, session_id: str) -> bool:
        """Stop an active session"""
        if session_id in self.active_sessions:
            session = self.active_sessions[session_id]
            session.status = 'stopped'
            session.end_time = datetime.now()
            self._update_session_status(session_id, 'stopped')
            del self.active_sessions[session_id]
            return True
        return False
    
    def generate_exploitation_report(self, session_id: str) -> Dict[str, Any]:
        """Generate exploitation report for a session"""
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")
        
        session = self.active_sessions[session_id]
        
        # Get results from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM exploit_results WHERE session_id = ?', (session_id,))
        exploit_results = cursor.fetchall()
        
        cursor.execute('SELECT * FROM privesc_results WHERE session_id = ?', (session_id,))
        privesc_results = cursor.fetchall()
        
        cursor.execute('SELECT * FROM exfil_results WHERE session_id = ?', (session_id,))
        exfil_results = cursor.fetchall()
        
        conn.close()
        
        # Generate report
        report = {
            'session_id': session_id,
            'target': session.target,
            'session_type': session.session_type,
            'status': session.status,
            'start_time': session.start_time.isoformat(),
            'end_time': session.end_time.isoformat() if session.end_time else None,
            'safety_mode': session.safety_mode,
            'exploit_results': len(exploit_results),
            'privesc_results': len(privesc_results),
            'exfil_results': len(exfil_results),
            'summary': {
                'total_attempts': len(exploit_results) + len(privesc_results) + len(exfil_results),
                'successful_exploits': sum(1 for r in exploit_results if r[2]),
                'successful_privesc': sum(1 for r in privesc_results if r[3]),
                'successful_exfil': sum(1 for r in exfil_results if r[9])
            }
        }
        
        return report

# Global exploit manager instance
exploit_manager = None

def initialize_exploit_manager(config_path: str = 'exploitation_config.yml'):
    """Initialize the global exploit manager"""
    global exploit_manager
    exploit_manager = ExploitManager(config_path)
    return exploit_manager

def get_exploit_manager() -> ExploitManager:
    """Get the global exploit manager instance"""
    if exploit_manager is None:
        raise RuntimeError("Exploit manager not initialized. Call initialize_exploit_manager() first.")
    return exploit_manager 